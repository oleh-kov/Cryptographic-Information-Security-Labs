# Обмін ключами по протоколу Діффі-Хелмана

## Задача

Реалізувати протокол обміну ключами Діффі-Хеллмана, який дозволяє двом сторонам обмінятися секретним ключем через незахищений канал.

### Як працює алгоритм (написав для себе, щоб не забути)
- Протокол Діффі-Хеллмана дозволяє двом сторонам обмінятися секретним ключем через незахищений канал.
- Обидві сторони генерують публічні ключі, якими обмінюються між собою.
- Використовуючи отриманий публічний ключ іншої сторони та свій секретний ключ, кожна сторона обчислює спільний секретний ключ.
- Спільний секретний ключ використовується для шифрування даних, що передаються між сторонами.

### Для чого це потрібно
- Це основа для створення захищених комунікаційних каналів, таких як HTTPS, VPN, і т.д.
- Забезпечує конфіденційність переданих даних навіть через незахищені мережі.

## Детальне пояснення роботи програми

### Кроки програми:

1. **Генерація безпечного простого числа \( p \)**:
   - Використовується функція `generate_secure_prime`, яка генерує просте число \( p \) у вигляді \( 2q + 1 \), де \( q \) також просте.
   - Для перевірки простоти використовується тест Міллера-Рабіна.

2. **Пошук генератора \( g \)**:
   - Використовується функція `find_generator`, щоб знайти генератор для мультиплікативної групи \( Z_p \).
   - Генератор \( g \) повинен задовольняти умову \( g^{(p-1)/2} \mod p \neq 1 \).

3. **Обчислення секретних та публічних ключів**:
   - Кожна сторона (Аліса і Боб) генерує свій секретний ключ \( a \) та \( b \).
   - Обчислюються публічні ключі \( A = g^a \mod p \) та \( B = g^b \mod p \).

4. **Обчислення спільного секретного ключа**:
   - Аліса обчислює спільний секретний ключ як \( B^a \mod p \).
   - Боб обчислює спільний секретний ключ як \( A^b \mod p \).
   - Обидва секрети повинні співпадати, що перевіряється за допомогою assert.

5. **Тестування**:
   - Функція `test_diffie_hellman` запускає весь процес і виводить спільний секретний ключ.
